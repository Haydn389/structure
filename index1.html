<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>보 전단력 및 굽힘 모멘트 계산기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #2d3748; /* Darker container background */
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.2);
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .input-section {
            background-color: #4a5568; /* Even darker section background */
            border-radius: 8px;
            padding: 20px;
        }
        .output-section {
            background-color: #4a5568; /* Even darker section background */
            border-radius: 8px;
            padding: 20px;
            display: flex; /* Use flexbox for output section content */
            flex-direction: column; /* Stack children vertically */
        }
        .output-header {
            display: flex;
            flex-direction: column; /* Default to column on small screens */
            justify-content: space-between;
            align-items: flex-start; /* Align items to the top */
            width: 100%;
            margin-bottom: 20px; /* Space below the header */
        }
        .output-header h2 {
            margin-bottom: 0; /* Remove default margin from h2 */
        }
        .output-header .visual-container {
            flex-shrink: 0; /* Prevent shrinking */
            text-align: left; /* Align text to the left on mobile */
            width: 100%; /* Take full width on mobile */
            margin-top: 20px; /* Space between output title and visual on mobile */
        }
        .output-header .visual-container h3 {
            margin-bottom: 10px; /* Space between title and canvas */
        }

        h1, h2 {
            color: #63b3ed; /* Blue headings */
            font-weight: 700;
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #cbd5e0;
        }
        input[type="number"], select {
            width: 100%;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #718096;
            background-color: #2d3748;
            color: #e2e8f0;
            margin-bottom: 15px;
            box-sizing: border-box;
        }
        button {
            background-color: #63b3ed;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 700;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #4299e1;
        }
        .load-item {
            background-color: #2d3748;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: flex-end;
        }
        .load-item > div {
            flex: 1;
            min-width: 120px;
        }
        .load-item button {
            background-color: #e53e3e;
            padding: 8px 12px;
            font-size: 0.875rem;
        }
        .load-item button:hover {
            background-color: #c53030;
        }
        canvas {
            background-color: #1a202c;
            border-radius: 8px;
            border: 1px solid #718096;
            width: 100%; /* Make canvas responsive */
            height: auto; /* Maintain aspect ratio */
            max-height: 400px; /* Max height for diagrams */
            margin-top: 15px;
        }
        #beamVisualCanvas {
            width: 100%; /* Take full width on mobile */
            height: 280px; /* Increased height for visual representation */
            margin-top: 0; /* Remove top margin as it's in a flex container */
        }
        @media (min-width: 768px) {
            .container {
                flex-direction: row;
            }
            .input-section {
                flex: 1;
            }
            .output-section {
                flex: 2;
            }
            .output-header {
                flex-direction: row; /* Row on larger screens */
                align-items: flex-start;
            }
            .output-header .visual-container {
                text-align: right; /* Align text to the right on desktop */
                width: auto; /* Auto width on desktop */
                margin-top: 0; /* No top margin on desktop */
            }
            #beamVisualCanvas {
                width: 500px; /* Fixed width for visual canvas on larger screens */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="input-section">
            <h2>입력 조건</h2>
            <div>
                <label for="beamLength">보의 길이 (m):</label>
                <input type="number" id="beamLength" value="10" min="1" step="0.1" oninput="calculateAndDraw()">
            </div>
            <!-- 보의 단면 입력 필드 삭제됨 -->
            <div>
                <label for="supportCondition">양단 지지조건:</label>
                <select id="supportCondition" onchange="calculateAndDraw()">
                    <option value="simplySupported">단순 지지 (Pinned-Roller)</option>
                    <option value="cantilever">외팔보 (Fixed-Free)</option>
                    <option value="fixedFixed">양단 고정 (Fixed-Fixed)</option>
                </select>
                <p class="text-sm text-gray-400 mt-1">양단 고정 조건은 전체 길이에 걸쳐 작용하는 등분포/변화분포 하중 및 집중 하중에 대해 정확하게 계산됩니다. 부분 하중의 경우 근사치가 될 수 있습니다.</p>
            </div>

            <h3 class="text-xl text-blue-300 mt-6 mb-4">하중 입력</h3>
            <div id="loadsContainer">
                <!-- Loads will be added here dynamically -->
            </div>
            <div class="flex gap-2 mt-4">
                <button onclick="addLoad('point')">집중하중 추가</button>
                <button onclick="addLoad('uniform')">분포하중 추가</button>
                <button onclick="addLoad('varying')">변화분포하중 추가</button>
            </div>

            <button class="w-full mt-8" onclick="calculateAndDraw()">계산 및 그리기</button>
        </div>

        <div class="output-section">
            <div class="output-header">
                <h2>출력</h2>
                <div class="visual-container">
                    <h3 class="text-xl text-blue-300">입력 조건 시각화</h3>
                    <canvas id="beamVisualCanvas"></canvas>
                </div>
            </div>

            <h3 class="text-xl text-blue-300 mb-2">전단력 선도 (Shear Force Diagram)</h3>
            <canvas id="sfdCanvas"></canvas>

            <h3 class="text-xl text-blue-300 mt-6 mb-2">굽힘 모멘트 선도 (Bending Moment Diagram)</h3>
            <canvas id="bmdCanvas"></canvas>
        </div>
    </div>

    <script>
        // Global variables
        const beamLengthInput = document.getElementById('beamLength');
        const supportConditionSelect = document.getElementById('supportCondition');
        const sfdCanvas = document.getElementById('sfdCanvas');
        const bmdCanvas = document.getElementById('bmdCanvas');
        const beamVisualCanvas = document.getElementById('beamVisualCanvas');
        const sfdCtx = sfdCanvas.getContext('2d');
        const bmdCtx = bmdCanvas.getContext('2d');
        const beamVisualCtx = beamVisualCanvas.getContext('2d');
        const loadsContainer = document.getElementById('loadsContainer');

        let loads = []; // Array to store load data

        // Function to resize canvases
        function resizeCanvas() {
            const containerWidth = sfdCanvas.parentElement.clientWidth;
            sfdCanvas.width = containerWidth;
            sfdCanvas.height = 400; // Fixed height
            bmdCanvas.width = containerWidth;
            bmdCanvas.height = 400; // Fixed height
            // beamVisualCanvas width and height are controlled by CSS
            // and will be responsive based on parent container and media queries.
            // The drawing logic inside drawBeamVisual will scale to the current canvas dimensions.
        }

        // Adjust canvas size on initial load and window resize
        window.onload = () => {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            calculateAndDraw(); // Initial calculation and drawing
        };

        /**
         * Adds a new load input field to the UI.
         * @param {string} type - Type of load ('point', 'uniform', 'varying')
         */
        function addLoad(type) {
            const loadId = Date.now(); // Generate unique ID
            let loadHtml = `
                <div class="load-item" data-id="${loadId}" data-type="${type}">
                    <div>
                        <label>종류:</label>
                        <span class="text-blue-200">${type === 'point' ? '집중하중' : type === 'uniform' ? '등분포하중' : '변화분포하중'}</span>
                    </div>
            `;

            if (type === 'point') {
                loadHtml += `
                    <div>
                        <label for="magnitude-${loadId}">크기 (kN):</label>
                        <input type="number" id="magnitude-${loadId}" value="10" step="0.1" oninput="calculateAndDraw()">
                    </div>
                    <div>
                        <label for="position-${loadId}">위치 (m):</label>
                        <input type="number" id="position-${loadId}" value="5" min="0" step="0.1" oninput="calculateAndDraw()">
                    </div>
                `;
            } else if (type === 'uniform') {
                loadHtml += `
                    <div>
                        <label for="magnitude-${loadId}">크기 (kN/m):</label>
                        <input type="number" id="magnitude-${loadId}" value="2" step="0.1" oninput="calculateAndDraw()">
                    </div>
                    <div>
                        <label for="start-${loadId}">시작 위치 (m):</label>
                        <input type="number" id="start-${loadId}" value="2" min="0" step="0.1" oninput="calculateAndDraw()">
                    </div>
                    <div>
                        <label for="end-${loadId}">끝 위치 (m):</label>
                        <input type="number" id="end-${loadId}" value="8" min="0" step="0.1" oninput="calculateAndDraw()">
                    </div>
                `;
            } else if (type === 'varying') {
                loadHtml += `
                    <div>
                        <label for="startMagnitude-${loadId}">시작 크기 (kN/m):</label>
                        <input type="number" id="startMagnitude-${loadId}" value="0" step="0.1" oninput="calculateAndDraw()">
                    </div>
                    <div>
                        <label for="endMagnitude-${loadId}">끝 크기 (kN/m):</label>
                        <input type="number" id="endMagnitude-${loadId}" value="5" step="0.1" oninput="calculateAndDraw()">
                    </div>
                    <div>
                        <label for="start-${loadId}">시작 위치 (m):</label>
                        <input type="number" id="start-${loadId}" value="0" min="0" step="0.1" oninput="calculateAndDraw()">
                    </div>
                    <div>
                        <label for="end-${loadId}">끝 위치 (m):</label>
                        <input type="number" id="end-${loadId}" value="10" min="0" step="0.1" oninput="calculateAndDraw()">
                    </div>
                `;
            }

            loadHtml += `
                    <button onclick="removeLoad(${loadId})">삭제</button>
                </div>
            `;
            loadsContainer.insertAdjacentHTML('beforeend', loadHtml);
            calculateAndDraw(); // Recalculate after adding load
        }

        /**
         * Removes a load input field from the UI.
         * @param {number} id - Unique ID of the load to remove
         */
        function removeLoad(id) {
            const loadItem = document.querySelector(`.load-item[data-id="${id}"]`);
            if (loadItem) {
                loadItem.remove();
                calculateAndDraw(); // Recalculate after removing load
            }
        }

        /**
         * Reads data from all load input fields and updates the 'loads' array.
         */
        function getLoadsData() {
            loads = [];
            const loadItems = loadsContainer.querySelectorAll('.load-item');
            const beamLength = parseFloat(beamLengthInput.value);

            loadItems.forEach(item => {
                const type = item.dataset.type;
                const id = parseInt(item.dataset.id);
                let load = { id, type };

                if (type === 'point') {
                    load.magnitude = parseFloat(item.querySelector(`#magnitude-${id}`).value);
                    load.position = parseFloat(item.querySelector(`#position-${id}`).value);
                    // Validate position
                    if (isNaN(load.position) || load.position < 0 || load.position > beamLength) {
                        console.warn(`Point load position error: ${load.position} (outside 0-${beamLength} range). Adjusting.`);
                        load.position = Math.max(0, Math.min(beamLength, load.position)); // Force adjust within range
                    }
                } else if (type === 'uniform') {
                    load.magnitude = parseFloat(item.querySelector(`#magnitude-${id}`).value);
                    load.start = parseFloat(item.querySelector(`#start-${id}`).value);
                    load.end = parseFloat(item.querySelector(`#end-${id}`).value);
                    // Validate range
                    if (isNaN(load.start) || isNaN(load.end) || load.start < 0 || load.end > beamLength || load.start >= load.end) {
                        console.warn(`Uniform load range error: start ${load.start}, end ${load.end} (outside 0-${beamLength} range or start >= end). Adjusting.`);
                        load.start = Math.max(0, Math.min(beamLength, load.start));
                        load.end = Math.max(load.start + 0.01, Math.min(beamLength, load.end)); // Ensure min 0.01m length
                    }
                } else if (type === 'varying') {
                    load.startMagnitude = parseFloat(item.querySelector(`#startMagnitude-${id}`).value);
                    load.endMagnitude = parseFloat(item.querySelector(`#endMagnitude-${id}`).value);
                    load.start = parseFloat(item.querySelector(`#start-${id}`).value);
                    load.end = parseFloat(item.querySelector(`#end-${id}`).value);
                    // Validate range
                    if (isNaN(load.start) || isNaN(load.end) || load.start < 0 || load.end > beamLength || load.start >= load.end) {
                        console.warn(`Varying load range error: start ${load.start}, end ${load.end} (outside 0-${beamLength} range or start >= end). Adjusting.`);
                        load.start = Math.max(0, Math.min(beamLength, load.start));
                        load.end = Math.max(load.start + 0.01, Math.min(beamLength, load.end));
                    }
                }
                loads.push(load);
            });
        }

        /**
         * Calculates beam reactions based on support type and applied loads.
         * @param {number} L - Beam length
         * @param {Array<Object>} loads - Array of loads
         * @param {string} supportType - Type of support ('simplySupported', 'cantilever', 'fixedFixed')
         * @returns {Object} - { R_A, R_B, M_A, M_B } (Reactions and moments)
         */
        function calculateReactions(L, loads, supportType) {
            let R_A = 0, R_B = 0, M_A = 0, M_B = 0; // Initialize reactions and moments

            if (supportType === 'simplySupported') {
                let totalForce = 0;
                let momentAboutA = 0; // Sum of moments about point A (left end)

                loads.forEach(load => {
                    if (load.type === 'point') {
                        totalForce += load.magnitude;
                        momentAboutA += load.magnitude * load.position;
                    } else if (load.type === 'uniform') {
                        const length = load.end - load.start;
                        const equivalentForce = load.magnitude * length;
                        const centroidPos = load.start + length / 2;
                        totalForce += equivalentForce;
                        momentAboutA += equivalentForce * centroidPos;
                    } else if (load.type === 'varying') {
                        const length = load.end - load.start;
                        const w1 = load.startMagnitude;
                        const w2 = load.endMagnitude;

                        const rectForce = w1 * length;
                        const rectCentroid = load.start + length / 2;
                        totalForce += rectForce;
                        momentAboutA += rectForce * rectCentroid;

                        const triForce = (w2 - w1) * length / 2;
                        const triCentroid = load.start + (2 / 3) * length;
                        totalForce += triForce;
                        momentAboutA += triForce * triCentroid;
                    }
                });

                R_B = momentAboutA / L;
                R_A = totalForce - R_B;

            } else if (supportType === 'cantilever') { // Fixed at left, free at right
                loads.forEach(load => {
                    if (load.type === 'point') {
                        R_A += load.magnitude;
                        M_A += load.magnitude * load.position; // Assume clockwise moment as positive for calculation
                    } else if (load.type === 'uniform') {
                        const length = load.end - load.start;
                        const equivalentForce = load.magnitude * length;
                        const centroidPos = load.start + length / 2;
                        R_A += equivalentForce;
                        M_A += equivalentForce * centroidPos;
                    } else if (load.type === 'varying') {
                        const length = load.end - load.start;
                        const w1 = load.startMagnitude;
                        const w2 = load.endMagnitude;

                        const rectForce = w1 * length;
                        const rectCentroid = load.start + length / 2;
                        R_A += rectForce;
                        M_A += rectForce * rectCentroid;

                        const triForce = (w2 - w1) * length / 2;
                        const triCentroid = load.start + (2 / 3) * length;
                        R_A += triForce;
                        M_A += triForce * triCentroid;
                    }
                });
                M_A = -M_A; // Fixed end moment is opposite to load-induced moment (counter-clockwise positive)
                R_B = 0; // No reaction at free end

            } else if (supportType === 'fixedFixed') {
                // Fixed-Fixed beam is indeterminate, using formulas for fixed-end moments and reactions
                let totalRA = 0;
                let totalRB = 0;
                let totalMA_fem = 0; // Fixed-End Moment at A
                let totalMB_fem = 0; // Fixed-End Moment at B

                loads.forEach(load => {
                    if (load.type === 'point') {
                        const a = load.position;
                        const b = L - a;
                        totalMA_fem += -load.magnitude * a * b * b / (L * L);
                        totalMB_fem += load.magnitude * a * a * b / (L * L);
                        totalRA += load.magnitude * (b * b * (L + 2 * a)) / (L * L * L);
                        totalRB += load.magnitude * (a * a * (L + 2 * b)) / (L * L * L);
                    } else if (load.type === 'uniform') {
                        // Exact for full span UDL. For partial UDL, this is a simplification.
                        if (load.start <= 0.001 && load.end >= L - 0.001) { // Approximately full span
                            totalMA_fem += -load.magnitude * L * L / 12;
                            totalMB_fem += load.magnitude * L * L / 12;
                            totalRA += load.magnitude * L / 2;
                            totalRB += load.magnitude * L / 2;
                        } else {
                            // Fallback for partial uniform load on fixed-fixed.
                            console.warn(`Fixed-Fixed: Partial uniform load (start: ${load.start}, end: ${load.end}) is approximated. Exact fixed-end moments for partial loads are more complex.`);
                            const length = load.end - load.start;
                            const equivalentForce = load.magnitude * length;
                            const centroidPos = load.start + length / 2;
                            const R_B_temp = (equivalentForce * centroidPos) / L;
                            const R_A_temp = equivalentForce - R_B_temp;
                            totalRA += R_A_temp;
                            totalRB += R_B_temp;
                        }
                    } else if (load.type === 'varying') {
                        // Exact for full span varying load. Partial varying loads are even more complex.
                        if (load.start <= 0.001 && load.end >= L - 0.001) { // Approximately full span
                            const w1 = load.startMagnitude;
                            const w2 = load.endMagnitude;

                            // Uniform part
                            totalMA_fem += -w1 * L * L / 12;
                            totalMB_fem += w1 * L * L / 12;
                            totalRA += w1 * L / 2;
                            totalRB += w1 * L / 2;

                            // Triangular part (from 0 at start to (w2-w1) at end)
                            const deltaW = w2 - w1;
                            if (deltaW > 0) { // Increasing load
                                totalMA_fem += -deltaW * L * L / 30;
                                totalMB_fem += deltaW * L * L / 20;
                                totalRA += deltaW * L * (3 / 20);
                                totalRB += deltaW * L * (7 / 20);
                            } else if (deltaW < 0) { // Decreasing load (0 at end to -(w1-w2) at start)
                                const absDeltaW = Math.abs(deltaW);
                                totalMA_fem += absDeltaW * L * L / 20; // Flipped
                                totalMB_fem += -absDeltaW * L * L / 30; // Flipped
                                totalRA += absDeltaW * L * (7 / 20); // Flipped
                                totalRB += absDeltaW * L * (3 / 20); // Flipped
                            }
                        } else {
                            // Fallback for partial varying load on fixed-fixed.
                            console.warn(`Fixed-Fixed: Partial varying load (start: ${load.start}, end: ${load.end}) is approximated. Exact fixed-end moments for partial loads are highly complex.`);
                            const length = load.end - load.start;
                            const w1 = load.startMagnitude;
                            const w2 = load.endMagnitude;
                            const rectForce = w1 * length;
                            const triForce = (w2 - w1) * length / 2;
                            const equivalentForce = rectForce + triForce;
                            const rectCentroid = load.start + length / 2;
                            const triCentroid = load.start + (2 / 3) * length;
                            const momentAboutA_temp = rectForce * rectCentroid + triForce * triCentroid;
                            const R_B_temp = momentAboutA_temp / L;
                            const R_A_temp = equivalentForce - R_B_temp;
                            totalRA += R_A_temp;
                            totalRB += R_B_temp;
                        }
                    }
                });

                R_A = totalRA;
                R_B = totalRB;
                M_A = totalMA_fem; // Fixed-end moment at A
                M_B = totalMB_fem; // Fixed-end moment at B
            }

            return { R_A, R_B, M_A, M_B };
        }

        /**
         * Calculates Shear Force and Bending Moment values along the beam.
         * @param {number} L - Beam length
         * @param {Array<Object>} loads - Array of loads
         * @param {Object} reactions - Reactions { R_A, R_B, M_A, M_B }
         * @param {string} supportType - Type of support
         * @param {number} numPoints - Number of points to calculate
         * @returns {Object} - { shearForces, bendingMoments, positions }
         */
        function calculateSFDBMD(L, loads, reactions, supportType, numPoints = 1000) {
            const positions = [];
            const shearForces = [];
            const bendingMoments = [];
            const dx = L / (numPoints - 1);

            for (let i = 0; i < numPoints; i++) {
                const x = i * dx;
                positions.push(x);

                let V = 0; // Shear force
                let M = 0; // Bending moment

                // Apply left reaction R_A
                V += reactions.R_A;

                // Apply initial moment (fixed-end moment) M_A
                M += reactions.M_A;

                // Add moment due to R_A
                M += reactions.R_A * x;

                // Calculate for all loads
                loads.forEach(load => {
                    if (load.type === 'point') {
                        if (x >= load.position) {
                            V -= load.magnitude;
                            M -= load.magnitude * (x - load.position);
                        }
                    } else if (load.type === 'uniform') {
                        if (x > load.start) {
                            const effectiveEnd = Math.min(x, load.end);
                            const length = effectiveEnd - load.start;
                            V -= load.magnitude * length;
                            M -= load.magnitude * length * (x - (load.start + effectiveEnd) / 2);
                        }
                    } else if (load.type === 'varying') {
                        if (x > load.start) {
                            const effectiveEnd = Math.min(x, load.end);
                            const currentLength = effectiveEnd - load.start;
                            const w1 = load.startMagnitude;
                            const w2 = load.endMagnitude;

                            // Load magnitude at current x (linear interpolation)
                            const currentW = w1 + (w2 - w1) * (currentLength / (load.end - load.start));

                            // Rectangular part
                            const rectForce = w1 * currentLength;
                            const rectCentroid = load.start + currentLength / 2;
                            V -= rectForce;
                            M -= rectForce * (x - rectCentroid);

                            // Triangular part
                            const triHeight = currentW - w1;
                            const triForce = 0.5 * triHeight * currentLength;
                            const triCentroid = load.start + (2 / 3) * currentLength;
                            V -= triForce;
                            M -= triForce * (x - triCentroid);
                        }
                    }
                });
                shearForces.push(V);
                bendingMoments.push(M);
            }
            return { shearForces, bendingMoments, positions };
        }

        /**
         * Draws the Shear Force Diagram or Bending Moment Diagram on a canvas.
         * @param {CanvasRenderingContext2D} ctx - Canvas context
         * @param {HTMLCanvasElement} canvas - Canvas element
         * @param {Array<number>} values - Array of values to plot (shear force or bending moment)
         * @param {Array<number>} positions - Array of x-positions
         * @param {number} L - Beam length
         * @param {string} label - Y-axis label (e.g., 'V (kN)', 'M (kN·m)')
         * @param {Object} [reactions] - Reaction information (optional, for display on diagram)
         */
        function drawDiagram(ctx, canvas, values, positions, L, label, reactions = null) {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            const padding = 50;
            const plotWidth = canvas.width - 2 * padding;
            const plotHeight = canvas.height - 2 * padding;

            // X-axis scale
            const xScale = plotWidth / L;

            // Y-axis scale
            const maxAbsValue = Math.max(...values.map(Math.abs));
            const yScale = (plotHeight / 2) / (maxAbsValue > 0 ? maxAbsValue : 1); // Prevent division by zero

            // Origin (center of canvas)
            const originX = padding;
            const originY = canvas.height / 2;

            ctx.save(); // Save current canvas state

            // Background and grid
            ctx.strokeStyle = '#4a5568'; // Grid color
            ctx.lineWidth = 0.5;
            // X-axis grid
            for (let x = 0; x <= L; x += L / 10) { // 10 divisions
                ctx.beginPath();
                ctx.moveTo(originX + x * xScale, padding);
                ctx.lineTo(originX + x * xScale, canvas.height - padding);
                ctx.stroke();
            }
            // Y-axis grid (relative to center line)
            const numYGrids = 4; // 4 grids above and below
            for (let i = 1; i <= numYGrids; i++) {
                const yOffset = (plotHeight / 2) / numYGrids * i;
                ctx.beginPath(); // Top
                ctx.moveTo(padding, originY - yOffset);
                ctx.lineTo(canvas.width - padding, originY - yOffset);
                ctx.stroke();
                ctx.beginPath(); // Bottom
                ctx.moveTo(padding, originY + yOffset);
                ctx.lineTo(canvas.width - padding, originY + yOffset);
                ctx.stroke();
            }


            // X-axis (Beam)
            ctx.strokeStyle = '#cbd5e0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(originX, originY);
            ctx.lineTo(originX + plotWidth, originY);
            ctx.stroke();

            // X-axis label
            ctx.fillStyle = '#cbd5e0';
            ctx.font = '14px Inter';
            ctx.textAlign = 'center';
            ctx.fillText('보의 길이 (m)', canvas.width / 2, canvas.height - 15);

            // Y-axis label
            ctx.save();
            ctx.translate(15, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText(label, 0, 0);
            ctx.restore();

            // Y-axis value labels
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText(maxAbsValue.toFixed(2), padding - 5, originY - (plotHeight / 2));
            ctx.fillText('0', padding - 5, originY);
            ctx.fillText((-maxAbsValue).toFixed(2), padding - 5, originY + (plotHeight / 2));


            // Draw diagram line
            ctx.strokeStyle = '#63b3ed'; // Diagram line color (blue)
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(originX + positions[0] * xScale, originY - values[0] * yScale);
            for (let i = 1; i < positions.length; i++) {
                ctx.lineTo(originX + positions[i] * xScale, originY - values[i] * yScale);
            }
            ctx.stroke();

            // Display key values (start, end, max/min)
            ctx.fillStyle = '#e2e8f0'; // Text color
            ctx.font = '12px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';

            // Start point value
            ctx.fillText(values[0].toFixed(2), originX + positions[0] * xScale, originY - values[0] * yScale - 5);
            // End point value
            ctx.fillText(values[values.length - 1].toFixed(2), originX + positions[positions.length - 1] * xScale, originY - values[values.length - 1] * yScale - 5);

            // Find and display max/min values
            let maxVal = -Infinity;
            let minVal = Infinity;
            let maxIdx = -1;
            let minIdx = -1;

            for (let i = 0; i < values.length; i++) {
                if (values[i] > maxVal) {
                    maxVal = values[i];
                    maxIdx = i;
                }
                if (values[i] < minVal) {
                    minVal = values[i];
                    minIdx = i;
                }
            }

            // Display max value (if not zero, or if zero but other values are not all zero)
            if (maxVal !== 0 || (maxVal === 0 && minVal === 0 && values.some(v => v !== 0))) {
                 ctx.fillText(`Max: ${maxVal.toFixed(2)}`, originX + positions[maxIdx] * xScale, originY - values[maxIdx] * yScale - 5);
            }
            // Display min value
            if (minVal !== 0 || (maxVal === 0 && minVal === 0 && values.some(v => v !== 0))) {
                ctx.fillText(`Min: ${minVal.toFixed(2)}`, originX + positions[minIdx] * xScale, originY - values[minIdx] * yScale + 15);
            }


            // Display reactions (only on Shear Force Diagram)
            if (label.includes('V (kN)') && reactions) {
                ctx.fillStyle = '#a0aec0'; // Gray color
                ctx.font = '12px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';

                // R_A
                ctx.fillText(`RA: ${reactions.R_A.toFixed(2)} kN`, originX, originY + 20);

                // R_B (for simply supported or fixed-fixed)
                if (supportConditionSelect.value === 'simplySupported' || supportConditionSelect.value === 'fixedFixed') {
                    ctx.fillText(`RB: ${reactions.R_B.toFixed(2)} kN`, originX + plotWidth, originY + 20);
                }
                // M_A (for cantilever or fixed-fixed)
                if (supportConditionSelect.value === 'cantilever' || supportConditionSelect.value === 'fixedFixed') {
                    ctx.fillText(`MA: ${reactions.M_A.toFixed(2)} kN·m`, originX, originY + 35); // Adjust moment position
                }
                // M_B (for fixed-fixed)
                if (supportConditionSelect.value === 'fixedFixed') {
                    ctx.fillText(`MB: ${reactions.M_B.toFixed(2)} kN·m`, originX + plotWidth, originY + 35); // Adjust moment position
                }
            }

            ctx.restore(); // Restore canvas state
        }

        /**
         * Draws the visual representation of the beam, loads, and supports.
         */
        function drawBeamVisual() {
            const ctx = beamVisualCtx;
            const canvas = beamVisualCanvas;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const beamLength = parseFloat(beamLengthInput.value);
            const supportType = supportConditionSelect.value;

            const padding = 30;
            const beamY = canvas.height / 2;
            const plotWidth = canvas.width - 2 * padding;
            const xScale = plotWidth / beamLength;

            // Draw beam
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(padding, beamY);
            ctx.lineTo(padding + plotWidth, beamY);
            ctx.stroke();

            // Draw supports
            ctx.fillStyle = '#a0aec0'; // Support color
            ctx.strokeStyle = '#a0aec0';
            ctx.lineWidth = 2;

            if (supportType === 'simplySupported') {
                // Pinned support (left)
                ctx.beginPath();
                ctx.moveTo(padding, beamY);
                ctx.lineTo(padding - 10, beamY + 20);
                ctx.lineTo(padding + 10, beamY + 20);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.beginPath(); // Ground line
                ctx.moveTo(padding - 15, beamY + 20);
                ctx.lineTo(padding + 15, beamY + 20);
                ctx.stroke();

                // Roller support (right)
                const rollerX = padding + plotWidth;
                ctx.beginPath();
                ctx.moveTo(rollerX, beamY);
                ctx.lineTo(rollerX - 10, beamY + 20);
                ctx.lineTo(rollerX + 10, beamY + 20);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.beginPath(); // Roller circles
                ctx.arc(rollerX - 5, beamY + 25, 5, 0, Math.PI * 2);
                ctx.arc(rollerX + 5, beamY + 25, 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath(); // Ground line
                ctx.moveTo(rollerX - 15, beamY + 30);
                ctx.lineTo(rollerX + 15, beamY + 30);
                ctx.stroke();

            } else if (supportType === 'cantilever' || supportType === 'fixedFixed') {
                // Fixed support (left)
                ctx.beginPath();
                ctx.moveTo(padding, beamY - 20);
                ctx.lineTo(padding, beamY + 20);
                ctx.stroke();
                // Hatching
                for (let i = -20; i <= 20; i += 5) {
                    ctx.beginPath();
                    ctx.moveTo(padding, beamY + i);
                    ctx.lineTo(padding - 10, beamY + i + 10);
                    ctx.stroke();
                }
                if (supportType === 'fixedFixed') {
                    // Fixed support (right)
                    const fixedRightX = padding + plotWidth;
                    ctx.beginPath();
                    ctx.moveTo(fixedRightX, beamY - 20);
                    ctx.lineTo(fixedRightX, beamY + 20);
                    ctx.stroke();
                    // Hatching
                    for (let i = -20; i <= 20; i += 5) {
                        ctx.beginPath();
                        ctx.moveTo(fixedRightX, beamY + i);
                        ctx.lineTo(fixedRightX + 10, beamY + i + 10);
                        ctx.stroke();
                    }
                }
            }

            // Draw loads
            ctx.fillStyle = '#ffffff'; // Load text color (white)
            ctx.strokeStyle = '#87ceeb'; // Load color (sky blue)
            ctx.lineWidth = 2;
            ctx.font = '10px Inter'; // Smaller font for visual labels
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';

            loads.forEach(load => {
                if (load.type === 'point') {
                    const x = padding + load.position * xScale;
                    const arrowHeight = 30;
                    ctx.beginPath();
                    ctx.moveTo(x, beamY - arrowHeight);
                    ctx.lineTo(x, beamY);
                    ctx.stroke();
                    // Arrowhead
                    ctx.beginPath();
                    ctx.moveTo(x, beamY);
                    ctx.lineTo(x - 5, beamY - 10);
                    ctx.moveTo(x, beamY);
                    ctx.lineTo(x + 5, beamY - 10);
                    ctx.stroke();
                    ctx.fillText(`${load.magnitude}kN`, x, beamY - arrowHeight - 5); // Label
                } else if (load.type === 'uniform') {
                    const startX = padding + load.start * xScale;
                    const endX = padding + load.end * xScale;
                    const loadHeight = 20;
                    ctx.beginPath();
                    ctx.rect(startX, beamY - loadHeight, endX - startX, loadHeight);
                    ctx.stroke();
                    // Arrows
                    for (let x = startX + 5; x < endX; x += 15) {
                        ctx.beginPath();
                        ctx.moveTo(x, beamY - loadHeight);
                        ctx.lineTo(x, beamY);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x, beamY);
                        ctx.lineTo(x - 3, beamY - 5);
                        ctx.moveTo(x, beamY);
                        ctx.lineTo(x + 3, beamY - 5);
                        ctx.stroke();
                    }
                    ctx.fillText(`${load.magnitude}kN/m`, (startX + endX) / 2, beamY - loadHeight - 5);
                } else if (load.type === 'varying') {
                    const startX = padding + load.start * xScale;
                    const endX = padding + load.end * xScale;
                    const maxLoadHeight = 30; // Max visual height for varying load

                    // Scale magnitudes to visual height
                    // Ensure denominator is not zero
                    const maxMag = Math.max(load.startMagnitude, load.endMagnitude, 0.1);
                    const h1 = (load.startMagnitude / maxMag) * maxLoadHeight;
                    const h2 = (load.endMagnitude / maxMag) * maxLoadHeight;

                    ctx.beginPath();
                    ctx.moveTo(startX, beamY - h1);
                    ctx.lineTo(endX, beamY - h2);
                    ctx.lineTo(endX, beamY);
                    ctx.lineTo(startX, beamY);
                    ctx.closePath();
                    ctx.stroke(); // Draw trapezoid outline

                    // Arrows (simplified, just a few)
                    const numArrows = 5;
                    for (let i = 0; i <= numArrows; i++) {
                        const currentX = startX + (endX - startX) * (i / numArrows);
                        const currentH = h1 + (h2 - h1) * (i / numArrows);
                        ctx.beginPath();
                        ctx.moveTo(currentX, beamY - currentH);
                        ctx.lineTo(currentX, beamY);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(currentX, beamY);
                        ctx.lineTo(currentX - 3, beamY - 5);
                        ctx.moveTo(currentX, beamY);
                        ctx.lineTo(currentX + 3, beamY - 5);
                        ctx.stroke();
                    }
                    ctx.fillText(`${load.startMagnitude}kN/m`, startX, beamY - h1 - 5);
                    ctx.fillText(`${load.endMagnitude}kN/m`, endX, beamY - h2 - 5);
                }
            });
        }


        /**
         * Main function to trigger calculation and drawing processes.
         */
        function calculateAndDraw() {
            getLoadsData(); // Get current load data from inputs
            const beamLength = parseFloat(beamLengthInput.value);
            const supportType = supportConditionSelect.value;

            if (isNaN(beamLength) || beamLength <= 0) {
                console.error('Please enter a valid beam length.');
                return;
            }

            // Draw visual representation of inputs
            drawBeamVisual();

            // Calculate reactions
            const reactions = calculateReactions(beamLength, loads, supportType);

            // Calculate SFD and BMD values
            const { shearForces, bendingMoments, positions } = calculateSFDBMD(beamLength, loads, reactions, supportType);

            // Draw SFD
            drawDiagram(sfdCtx, sfdCanvas, shearForces, positions, beamLength, '전단력 V (kN)', reactions);

            // Draw BMD
            drawDiagram(bmdCtx, bmdCanvas, bendingMoments, positions, beamLength, '굽힘 모멘트 M (kN·m)');
        }

        // Add initial example loads and set up real-time updates
        addLoad('point');
        addLoad('uniform');
        addLoad('varying');
    </script>
</body>
</html>
